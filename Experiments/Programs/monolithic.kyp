/* @evidence: generated by KeYmaeraX 4.6.3 -launch -tool z3 -prove .\correct\monolithic */

/* @evidence: parse of print of result of a proof */

Lemma "<undefined>".
Sequent.

==>
Formula: ((((xl)-(x)) >= ((10)))&(((v) <= ((2.7)))&(((((Verror())*(Verror()))/(Verror())) <= ((0.03)))&(((B()) >= ((5)))&(((A()) <= ((4)))&(((vl) >= ((0)))&(((v) >= ((0)))&(((b()) >= ((5)))&(((B()) > (b()))&(((A()) > ((0)))&(((A()) <= ((4)))&(((lw()) > ((0)))&(((y) = (ly()))&(((((v)^((2)))/(((2))*(b()))) < ((lw())/((2))))&(((v) >= ((0)))&(((v) <= ((2.7)))&(((ep()) > ((0)))&(((W()) <= ((0.3)))&(((caf()) = ((90000)))&(((lf()) = ((1.073)))&(((lr()) = ((1.667)))&(((m()) = ((2045)))&(((Jz()) = ((4115)))&(((car()) = ((86915)))&(((Verror()) = ((0.03)))&(((minDist()) = ((10)))&(((beta) = ((0)))&(((dPsi) = ((0)))&((Psi2) = ((0)))))))))))))))))))))))))))))))->([{{{{{a:=*;};{{?(((-(B())) <= (a))&((a) <= (A())));};{{K:=*;};{{?((((-0.008)) <= (K))&(((K) <= ((0.008)))&((K) != ((0)))));};{{delta:=((lr())+(lf()))/(K);};{{?(((-(W())) <= (delta))&((delta) <= (W())));};{?((((abs((y)-(ly())))+(((v)^((2)))/(((2))*(b()))))+((((A())/(b()))+((1)))*((((A())/((2)))*((ep())^((2))))+((ep())*(v))))) < ((lw())/((2))));}}}}}}}++{{?((v) = ((0)));};{{a:=(0);};{delta:=(0);}}}};{{t:=(0);};{{x'=v,v'=a,xl'=vl,vl'=al,beta'=((-(((beta)*((caf())+(car())))/((m())*(v))))+((Psi2)*(((-1))-((((caf())*(lf()))-((car())*(lr())))/(((m())*(v))*(v))))))+(((caf())/((m())*(v)))*(delta)),Psi2'=((((((-1))*(((caf())*(lf()))-((car())*(lr()))))/(Jz()))*(beta))+(((((-1))*((((caf())*(lf()))*(lf()))-(((car())*(lr()))*(lr()))))/((Jz())*(v)))*(Psi2)))+((((caf())*(lf()))/(Jz()))*(delta)),y'=(v)*((beta)+(dPsi)),dPsi'=(-(Psi2))+((v)*(K)),t'=(1)&((t) <= (ep()))&(((v) >= ((0)))&((vl) >= ((0))))}}}}*}++{{{{al:=*;};{?(((-(B())) <= (al))&((al) <= (A())));}};{{{?(!((((xl)-(x))-(minDist())) <= (((((v)*(v))-((vl)*(vl)))/(((2))*(B())))+((((A())/(B()))+((1)))*(((((A())/((2)))*(ep()))*(ep()))+((ep())*(v)))))));};{{{?((v) > (vl));};{{a:=*;};{?(((-(B())) <= (a))&((a) <= (A())));}}}++{{?((v) <= (vl));};{{a:=*;};{?(((-(B())) <= (a))&((a) <= (A())));}}}}};{{{?((((xl)-(x))-(minDist())) <= (((((v)*(v))-((vl)*(vl)))/(((2))*(B())))+((((A())/(B()))+((1)))*(((((A())/((2)))*(ep()))*(ep()))+((ep())*(v))))));};{a:=-(B());}};{{x'=v,v'=a,xl'=vl,vl'=al,beta'=((-(((beta)*((caf())+(car())))/((m())*(v))))+((Psi2)*(((-1))-((((caf())*(lf()))-((car())*(lr())))/(((m())*(v))*(v))))))+(((caf())/((m())*(v)))*(delta)),Psi2'=((((((-1))*(((caf())*(lf()))-((car())*(lr()))))/(Jz()))*(beta))+(((((-1))*((((caf())*(lf()))*(lf()))-(((car())*(lr()))*(lr()))))/((Jz())*(v)))*(Psi2)))+((((caf())*(lf()))/(Jz()))*(delta)),y'=(v)*((beta)+(dPsi)),dPsi'=(-(Psi2))+((v)*(K)),t'=(1)&((t) <= (ep()))&(((v) >= ((0)))&((vl) >= ((0))))}}}}}*}]((((ly())-((lw())/((2)))) < (y))&(((y) < ((ly())+((lw())/((2)))))&(((xl)-(x)) >= ((10))))))

End.
Tool.
  tool """"KeYmaera X""""
  model """"Functions.
  R b(). /* minimum */
  R B().
  R A().  /* Maximum acceleration */
  R ep().
  R lw(). /*lane width (max distance) */
  R ly(). /* center of the lane */
  R W().       /* maximum steering rate */
  R abs(R).    /* predefined function of absolute value */
  R caf.
  R lf.
  R lr.
  R m.
  R Jz.
  R car.
  R minDist().
  R Vset().
 R Verror().
  
  HP leader ::= {
    al:=*; ?(-B() <= al & al <= A());
  }.

  /* train controller */
  HP follow ::= {
        ?(!(xl-x-minDist() <= (v*v-vl*vl)/(2*B()) + (A()/B()+1)*(A()/2*ep()*ep()+ep()*v)));
        { ?v > vl; a:=*;?(-B() <= a & a <= A());
        ++
          ?v <= vl; a:=*;?(-B() <= a & a <= A()); }

  }.

  /* Initial states */
  B initial() <-> (
    b()>=5 &    B() > b() &                                                                      /* brakes are working */
    A()>0 & A() <= 4 &  lw() > 0 &
    y = ly() & (v^2)/(2*b) < lw()/2 & /* safe state */
    v>=0 & v <= 2.7 & ep() > 0 & W() <= 0.3 & caf = 90000 & lf = 1.073 &  lr = 1.667 & m = 2045 & Jz = 4115 & car = 86915
    & Verror() = 0.03 & minDist() = 10
   & beta = 0 & dPsi = 0 & Psi2 = 0  /*inital state -> just straight line*/
  ).

 B safetyHard(R y, R v) <-> (
    abs(y-ly()) + (v^2)/(2*b())+(A()/b() + 1)*((A()/2)*ep()^2 + ep()*v) < lw()/2
  ).
  
  HP safetyKeep ::= {
        ?(xl-x-minDist()  <= (v*v-vl*vl)/(2*B()) + (A()/B()+1)*(A()/2*ep()*ep()+ep()*v));
           a:= -B();
  }.

 HP ctrl::= {
  { a:=*; ?-B() <= a & a <= A();
    K:=*; ?(-0.008 <= K & K <= 0.008 & K != 0);
    delta:= (lr+lf)/K; ?-W()<=delta & delta<=W();
    ?safetyHard(y,v);
  }
  ++ {?v=0; a:=0; delta:=0;}
}.

 HP drive ::= {                                               
    {x'=v,  v' = a,/*longitudinal*/ 
    xl'=vl,     
    vl'=al,                   
     beta' = -beta*(caf+car)/(m*v) + Psi2*(-1 - (caf*lf-car*lr)/(m*v*v)) + caf/(m*v)*delta,
     Psi2' = (-1*(caf*lf - car*lr)/Jz)*beta + (-1* (caf*lf*lf - car*lr*lr)/(Jz*v))*Psi2 + (caf*lf/Jz)*delta,
     y' = v*(beta + dPsi),
     dPsi' = -Psi2 + v*K, t' = 1 &  t <= ep() & v >= 0 & vl >= 0}                       
  }.

End.

ProgramVariables. /* program variables may change their value over time */
  R x.
  R y.
  R v.
  R a.
  R xl.            /* position of the car */
  R vl.            /* velocity of the car */
  R al.
  R Psi2.
  R dPsi.
  R beta.
  R delta.
  R K.
  R t.            /* clock variable */
End.


Problem.          /* differential dynamic logic formula */
     (xl - x) >= 10 & v <= 2.7 & (Verror() * Verror())/Verror() <= 0.03 & B() >= 5 & A() <= 4 & vl>=0 & v>=0 & initial()
 -> [
      {
        ctrl;
        t:= 0;  
        drive;
      }*@invariant(v >= 0  & abs(y-ly()) + (v^2)/(2*b) < lw()/2)
      ++
      {
        leader;
        follow;
        safetyKeep;
        drive;
      }*@invariant(xl-x>=minDist())
    ] (ly()-lw()/2 < y & y < ly()+lw()/2 & (xl-x) >= 10)
End.


Tactic "Automated proof"
master ; <(
  boxAnd(1) ; andR(1) ; <(
    loop({`ly()-lw()/2 < y`}, 1) ; <(
      master,
      master,
      master ; dC({`y=old(y)`}, 1) ; <(
        dC({`v<=0`}, 1) ; <(
          master,
          master
          ),
        master ; dC({`y=old(y)`}, 1) ; <(
          master,
          master ; dC({`v<=0`}, 1) ; <(
            master,
            master
            )
          )
        )
      ),
    loop({`abs(y-ly())+v^2/(2*b()) < lw()/2&xl-x>=10`}, 1) ; <(
      master,
      master,
      master ; <(
        GV(1) ; master,
        dC({`y=old(y)`}, 1) ; <(
          master ; master ; dC({`v<=0`}, 1) ; <(
            master,
            master
            ),
          dC({`v=0`}, 1) ; <(
            master,
            master
            )
          )
        )
      )
    ),
  loop({`abs(y-ly()) < lw()/2&xl-x>=10`}, 1) ; <(
    master,
    master,
    master ; <(
      notLessEqual(-15) ; GV(1) ; master,
      GV(1) ; master
      )
    )
  )
End.""""
  tactic """"(master&<( (boxAnd(1)&(andR(1)&<( (loop({`ly()-lw()/2 < y`},1)&<( master, master, (master&(dC({`y=old(y)`},1)&<( (dC({`v<=0`},1)&<( master, master )), (master&(dC({`y=old(y)`},1)&<( master, (master&(dC({`v<=0`},1)&<( master, master ))) ))) ))) )), (loop({`abs(y-ly())+v^2/(2*b()) < lw()/2&xl-x>=10`},1)&<( master, master, (master&<( (GV(1)&master), (dC({`y=old(y)`},1)&<( (master&(master&(dC({`v<=0`},1)&<( master, master )))), (dC({`v=0`},1)&<( master, master )) )) )) )) ))), (loop({`abs(y-ly()) < lw()/2&xl-x>=10`},1)&<( master, master, (master&<( (notLessEqual(-15)&(GV(1)&master)), (GV(1)&master) )) )) ))""""
  proof """"""""
End.
